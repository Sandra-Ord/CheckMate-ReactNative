drop table if exists collection_users cascade;
drop table if exists task_logs cascade;
drop table if exists notifications cascade;
drop table if exists activities cascade;
drop table if exists tasks cascade;
drop table if exists task_photos cascade;
drop table if exists collections cascade;
drop table if exists users cascade;
drop table if exists to_do_tags cascade;
drop table if exists to_do_tasks cascade;
drop table if exists tags cascade;

--Create users table
create table
    users
(
    id         text primary key,
    username   text,
    first_name text,
    email      text,
    avatar_url text,
    push_token text
);

-- Create collections table
create table
    collections
(
    id       bigint generated by default as identity primary key,
    owner_id text not null references users (id) on delete cascade,
    name     text not null
);

-- Create collection users table
create table
    collection_users
(
    id            bigint generated by default as identity primary key,
    collection_id bigint not null references collections (id) on delete cascade,
    invited_by_id text   not null references users (id) on delete cascade,
    user_id       text   not null references users (id) on delete cascade,
    role          text   not null,
    invited_at    timestamp with time zone default timezone('utc'::text, now()),
    responded_at  timestamp with time zone,
    status        text,
    order_nr      int    not null          default 0
);

-- Create tasks table
create table
    tasks
(
    id                     bigint generated by default as identity primary key,
    collection_id          bigint  not null references collections (id) on delete cascade,
    assigned_to_user_id    text references users (id) on delete cascade,
    name                   text    not null,
    description            text,
    recurring              boolean not null         default true,
    interval_value         int,
    interval_unit          text,
    day_of_week            int,
    date_of_month          int,
    month_of_year          int,
    season_start           timestamp with time zone,
    season_end             timestamp with time zone,
    last_completed_at      timestamp with time zone default timezone('utc'::text, now()),
    completion_start       timestamp with time zone,
    completion_window_days int,
    next_due_at            timestamp with time zone default timezone('utc'::text, now()),
    skip_missed_due_dates  boolean not null         default false,
    archived_at            timestamp with time zone
);

-- Create task log table
create table
    task_logs
(
    id           bigint generated by default as identity primary key,
    task_id      bigint                                                        not null references tasks (id) on delete cascade,
    user_id      text                                                          not null references users (id) on delete cascade,
    completed_at timestamp with time zone default timezone('utc'::text, now()) not null,
    due_at       timestamp with time zone,
    comment      text
);

-- Create notifications table
create table
    notifications
(
    id            bigint generated by default as identity primary key,
    user_id       text                                                          not null references users (id) on delete cascade,
    type          text                                                          not null,
    collection_id bigint references collections (id) on delete cascade,
    task_id       bigint references tasks (id) on delete cascade,
    about_user_id text references users (id) on delete cascade,
    data          jsonb,
    created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
    read_at       timestamp with time zone
);

-- Create activities table
create table
    activities
(
    id            bigint generated by default as identity primary key,
    user_id       text                                                          not null references users (id) on delete cascade,
    type          text                                                          not null,
    collection_id bigint references collections (id) on delete cascade,
    task_id       bigint references tasks (id) on delete cascade,
    about_user_id text references users (id) on delete cascade,
    data          jsonb,
    created_at    timestamp with time zone default timezone('utc'::text, now()) not null,
    read_at       timestamp with time zone
);

-- Create to do tasks table
create table
    task_photos
(
    id          bigint generated by default as identity primary key,
    task_id     bigint                                                        not null references tasks (id) on delete cascade,
    photo_url   text                                                          not null,
    uploaded_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create to do tasks table
create table
    to_do_tasks
(
    id           bigint generated by default as identity primary key,
    user_id      text                                                          not null references users (id) on delete cascade,
    name         text                                                          not null,
    comment      text,
    due_date     timestamp with time zone default timezone('utc'::text, now()),
    created_at   timestamp with time zone default timezone('utc'::text, now()) not null,
    completed_at timestamp with time zone
);

-- Create tags table
create table
    tags
(
    id          bigint generated by default as identity primary key,
    user_id     text                                                          not null references users (id) on delete cascade,
    tag         text                                                          not null,
    tag_icon    text,
    created_at  timestamp with time zone default timezone('utc'::text, now()) not null,
    archived_at timestamp with time zone
);

-- Create to to tags table
create table
    to_do_tags
(
    id            bigint generated by default as identity primary key,
    to_do_task_id bigint not null references to_do_tasks (id) on delete cascade,
    tag_id        bigint not null references tags (id) on delete cascade
);

-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ----------------------------- FUNCTIONS ---------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- Get JWT user id
CREATE
OR REPLACE FUNCTION requesting_user_id () RETURNS TEXT AS $$
SELECT NULLIF(
               current_setting('request.jwt.claims', true) ::json ->>'sub',
        ''
    )::text;
$$
LANGUAGE SQL STABLE;

-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ----------------------------- UNIQUE INDEXES ---------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- USER CAN ONLY HAVE ONE PENDING INVITATION TO A COLLECTION
-- ------------------------------------------------------------------------------------------------
CREATE UNIQUE INDEX unique_pending_invitation ON collection_users (collection_id, user_id) WHERE
  status IS NULL;

-- ------------------------------------------------------------------------------------------------
-- USER CAN ONLY HAVE ONE ACCEPTED INVITATION TO A COLLECTION
-- ------------------------------------------------------------------------------------------------
CREATE UNIQUE INDEX unique_accepted_invitation ON collection_users (collection_id, user_id) WHERE
  status = 'ACCEPTED';

-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ----------------------------- CONSTRAINTS ------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ONLY APPROVED INTERVAL UNITS ALLOWED
-- ------------------------------------------------------------------------------------------------
ALTER TABLE collection_users
    ADD CONSTRAINT valid_status CHECK (
        status IN ('ACCEPTED', 'REJECTED', 'CANCELLED', 'REMOVED')
            OR status IS NULL
        );

-- ------------------------------------------------------------------------------------------------
-- ORDER_NR IS A NON-NEGATIVE NUMBER
-- ------------------------------------------------------------------------------------------------
ALTER TABLE collection_users
    ADD CONSTRAINT order_nr_non_negative CHECK (order_nr >= 0);

-- ------------------------------------------------------------------------------------------------
-- INTERVAL VALUE AND UNIT ONLY ALLOWED FOR RECURRING TASK
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT valid_interval CHECK (
        (
            recurring
                AND interval_value IS NOT NULL
                AND interval_unit IS NOT NULL
            )
            OR (
            NOT recurring
                AND interval_value IS NULL
                AND interval_unit IS NULL
            )
        );

-- ------------------------------------------------------------------------------------------------
-- ONLY RECURRING TASKS CAN SKIP MISSED DUE DATES
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT chk_recurring_skip_missed_due_dates CHECK (
        recurring = true
            OR skip_missed_due_dates = false
        );

-- ------------------------------------------------------------------------------------------------
-- ONLY APPROVED INTERVAL UNITS ALLOWED
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT valid_interval_unit CHECK (
        interval_unit IN ('day', 'week', 'month', 'year')
            OR interval_unit IS NULL
        );

-- ------------------------------------------------------------------------------------------------
-- INTERVAL UNIT AND SPECIFIER CONSISTENCY CONSTRAINT
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT interval_unit_consistency CHECK (
        (
            interval_unit = 'day'
                AND day_of_week IS NULL
                AND date_of_month IS NULL
                AND month_of_year IS NULL
            )
            OR (
            interval_unit = 'week'
                AND (
                day_of_week IS NOT NULL
                    OR day_of_week IS NULL
                )
                AND date_of_month IS NULL
                AND month_of_year IS NULL
            )
            OR (
            interval_unit = 'month'
                AND (
                date_of_month IS NOT NULL
                    OR date_of_month is NULL
                )
                AND day_of_week IS NULL
                AND month_of_year IS NULL
            )
            OR (
            interval_unit = 'year'
                AND (
                (
                    month_of_year IS NULL
                        AND date_of_month IS NULL
                    )
                    OR (
                    month_of_year IS NOT NULL
                        AND date_of_month IS NULL
                    )
                    OR (
                    month_of_year IS NOT NULL
                        AND date_of_month IS NOT NULL
                    )
                )
                AND day_of_week IS NULL
            )
        );

-- ------------------------------------------------------------------------------------------------
-- SEASON START AND SEASON END EITHER BOTH EXIST OR BOTH ARE NULL
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT season_start_end_consistency CHECK (
        (
            season_start IS NOT NULL
                AND season_end IS NOT NULL
            )
            OR (
            season_start IS NULL
                AND season_end IS NULL
            )
        );

-- ------------------------------------------------------------------------------------------------
-- COMPLETION_WINDOW_DAYS IS A NON-NEGATIVE NUMBER OR NULL
-- ------------------------------------------------------------------------------------------------
ALTER TABLE tasks
    ADD CONSTRAINT completion_window_days_non_negative CHECK (
        completion_window_days >= 0
            OR completion_window_days IS NULL
        );

-- ------------------------------------------------------------------------------------------------
-- NOTIFICATION TYPE
-- ------------------------------------------------------------------------------------------------
ALTER TABLE notifications
    ADD CONSTRAINT valid_type CHECK (
        type IN (
                 'invitation',
                 'invitation_accepted',
                 'invitation_rejected',
                 'task_assigned',
                 'task_completion_window',
                 'task_due_soon',
                 'task_in_season',
                 'to_do_task_due_soon',
                 'user_joined_collection',
                 'user_left_collection'
            )
        );

-- ------------------------------------------------------------------------------------------------
-- INVITATION NOTIFICATION REQUIRES COLLECTION REFERENCE
-- ------------------------------------------------------------------------------------------------
ALTER TABLE notifications
    ADD CONSTRAINT invitation_requires_collection_id_no_task_id CHECK (
        (
            type IN (
                     'invitation',
                     'invitation_accepted',
                     'invitation_rejected',
                     'user_joined_collection',
                     'user_left_collection'
                )
                AND collection_id IS NOT NULL
                AND about_user_id IS NOT NULL
                AND task_id IS NULL
            )
            OR (
            type <> 'invitation'
            )
        );

-- ------------------------------------------------------------------------------------------------
-- TASK NOTIFICATIONS REQUIRE COLLECTION AND TASK REFERENCE
-- ------------------------------------------------------------------------------------------------
ALTER TABLE notifications
    ADD CONSTRAINT specific_types_require_both_ids CHECK (
        (
            type IN (
                     'task_assigned',
                     'task_completion_window',
                     'task_due_soon',
                     'task_in_season'
                )
                AND collection_id IS NOT NULL
                AND task_id IS NOT NULL
            )
            OR (
            type NOT IN (
                         'task_assigned',
                         'task_completion_window',
                         'task_due_soon',
                         'task_in_season'
                )
            )
        );

-- ------------------------------------------------------------------------------------------------
-- TO DO TASK NOTIFICATION DOES NOT HAVE COLLECTION OR TASK REFERENCE
-- ------------------------------------------------------------------------------------------------
ALTER TABLE notifications
    ADD CONSTRAINT to_do_task_due_soon_requires_no_ids CHECK (
        (
            type = 'to_do_task_due_soon'
                AND collection_id IS NULL
                AND task_id IS NULL
            )
            OR (
            type <> 'to_do_task_due_soon'
            )
        );

-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------ TRIGGERS --------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- SEND NOTIFICATION WHEN A TASK IS ASSIGNED
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION notify_task_assigned () RETURNS TRIGGER AS $$
BEGIN
    -- Notify when a task is created with an assigned_to_user_id
    IF
TG_OP = 'INSERT' AND NEW.assigned_to_user_id IS NOT NULL THEN
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            task_id,
            data,
            created_at
        )
        VALUES (
            -- Notification is sent to the person it is assigned to
            NEW.assigned_to_user_id,
            'task_assigned',
            NEW.collection_id,
            NEW.id,
            jsonb_build_object(
                'task_name', NEW.name,
                'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
            ),
            NOW()
        );
END IF;

    -- Notify when a task is updated with a new assigned_to_user_id
    IF
TG_OP = 'UPDATE' AND OLD.assigned_to_user_id IS DISTINCT FROM NEW.assigned_to_user_id THEN
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            task_id,
            data,
            created_at
        )
        VALUES (
            -- Notification is sent to the person it is assigned to
            NEW.assigned_to_user_id,
            'task_assigned',
            NEW.collection_id,
            NEW.id,
            jsonb_build_object(
                'task_name', NEW.name,
                'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
            ),
            NOW()
        );
END IF;

RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER notify_task_assigned_trigger
    AFTER INSERT
        OR
UPDATE OF assigned_to_user_id
ON tasks FOR EACH ROW
    EXECUTE FUNCTION notify_task_assigned ();

-- ------------------------------------------------------------------------------------------------
-- CREATE NOTIFICATION WHEN INVITED TO COLLECTION
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION create_invitation_notification () RETURNS TRIGGER AS $$
BEGIN
    -- Check if the status is NULL (a pending invitation)
    IF
NEW.status IS NULL THEN
        -- Insert a notification for the invited user
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            about_user_id,
            data,
            created_at
        )
        VALUES (
            -- Invitation notification is sent to the person who was invited
            NEW.user_id,
            'invitation',
            NEW.collection_id,
            NEW.invited_by_id,  -- about_user_id is the person who made the invite
            jsonb_build_object(
                'role', NEW.role,
                'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
            ),
            now()
        );
END IF;

    -- Return the new row for the trigger to be successful
RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER create_invitation_notification_trigger
    AFTER INSERT
    ON collection_users
    FOR EACH ROW WHEN (NEW.status IS NULL)
    EXECUTE FUNCTION create_invitation_notification ();

-- ------------------------------------------------------------------------------------------------
-- CREATE NOTIFICATION WHEN USER RESPONDS TO COLLECTION INVITATION
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION handle_invitation_status_change () RETURNS TRIGGER AS $$
BEGIN
    -- Check if the status was NULL and is now changed
    IF
OLD.status IS NULL AND NEW.status IN ('ACCEPTED', 'REJECTED') THEN
        -- Insert a notification for the inviter
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            about_user_id,
            data,
            created_at
        )
        VALUES (
            -- Notification about invitation response is sent to the inviter
            NEW.invited_by_id,
            CASE
                WHEN NEW.status = 'ACCEPTED' THEN 'invitation_accepted'
                WHEN NEW.status = 'REJECTED' THEN 'invitation_rejected'
            END,
            NEW.collection_id,
            NEW.user_id,  -- about_user_id is the person who responded
            jsonb_build_object(
                'role', NEW.role,
                'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
            ),
            now()
        );
END IF;

    -- Return the new row for the trigger to be successful
RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER handle_invitation_status_change_trigger
    AFTER
        UPDATE OF status
    ON collection_users
    FOR EACH ROW WHEN (
    OLD.status IS NULL
        AND NEW.status IN ('ACCEPTED', 'REJECTED')
    )
    EXECUTE FUNCTION handle_invitation_status_change ();

-- ------------------------------------------------------------------------------------------------
-- NOTIFY COLLECTION MEMBERS IF USER JOINS COLLECTION
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION notify_user_joined_collection () RETURNS TRIGGER AS $$
BEGIN
    -- Trigger only for status change from NULL to ACCEPTED
    IF
OLD.status IS NULL AND NEW.status = 'ACCEPTED' THEN
        -- Insert notifications for all other accepted users in the same collection
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            about_user_id,
            data,
            created_at
        )
SELECT
    -- Notification is sent to all the collection members if someone joins the collection,
    cu.user_id,
    'user_joined_collection',
    NEW.collection_id,
    NEW.user_id, -- about_user_id is the person who joined
    jsonb_build_object(
            'joined_user_role', NEW.role,
            'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
    ),
    NOW()
FROM collection_users cu
WHERE cu.collection_id = NEW.collection_id
  AND cu.status = 'ACCEPTED'
  AND cu.user_id != NEW.user_id;
END IF;

RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER notify_user_joined_collection_trigger
    AFTER
        UPDATE OF status
    ON collection_users
    FOR EACH ROW WHEN (
    OLD.status IS NULL
        AND NEW.status = 'ACCEPTED'
    )
    EXECUTE FUNCTION notify_user_joined_collection ();

-- ------------------------------------------------------------------------------------------------
-- NOTIFY COLLECTION MEMBERS IF USER LEAVES COLLECTION
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION notify_user_left_collection () RETURNS TRIGGER AS $$
BEGIN
    -- Trigger only for status change from ACCEPTED to CANCELLED
    IF
OLD.status = 'ACCEPTED' AND NEW.status = 'CANCELLED' THEN
        -- Insert notifications for all other accepted users in the same collection
        INSERT INTO notifications (
            user_id,
            type,
            collection_id,
            about_user_id,
            data,
            created_at
        )
SELECT
    -- Notification is sent to all the collection members if someone joins the collection,
    cu.user_id,
    'user_left_collection',
    NEW.collection_id,
    NEW.user_id, -- about_user_id is the person who left
    jsonb_build_object(
            'left_user_role', OLD.role,
            'collection_name', (SELECT name FROM collections WHERE id = NEW.collection_id)
    ),
    NOW()
FROM collection_users cu
WHERE cu.collection_id = NEW.collection_id
  AND cu.status = 'ACCEPTED'
  AND cu.user_id != NEW.user_id;
END IF;

RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER notify_user_left_collection_trigger
    AFTER
        UPDATE OF status
    ON collection_users
    FOR EACH ROW WHEN (
    OLD.status = 'ACCEPTED'
        AND NEW.status = 'CANCELLED'
    )
    EXECUTE FUNCTION notify_user_left_collection ();

-- ------------------------------------------------------------------------------------------------
-- IF USER CREATES A COLLECTION A COLLECTION_USER IS CREATED AUTOMATICALLY
-- ------------------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION insert_collection_user () RETURNS TRIGGER AS $$
BEGIN
    -- Insert a row into the collection_users table when a new collection is created
INSERT INTO collection_users (collection_id,
                              invited_by_id,
                              user_id,
                              role,
                              invited_at,
                              responded_at,
                              status)
VALUES (NEW.id,
        NEW.owner_id,
        NEW.owner_id,
        'OWNER',
        NOW(),
        NOW(),
        'ACCEPTED');

-- Return the new row for the trigger to be successful
RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER create_collection_user_trigger
    AFTER INSERT
    ON collections
    FOR EACH ROW
    EXECUTE FUNCTION insert_collection_user ();

-- -----------------------------------------------------------------------------------------
-- IF USER ENTERS A TASK, THE DATA IS CLEANED TO ENSURE THE QUALITY
-- -----------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION clean_task_data () RETURNS TRIGGER AS $$
BEGIN
    IF
NEW.recurring THEN
        CASE NEW.interval_unit
            WHEN 'day' THEN
                NEW.day_of_week := NULL;
                NEW.date_of_month
:= NULL;
                NEW.month_of_year
:= NULL;
WHEN 'week' THEN
                NEW.date_of_month := NULL;
                NEW.month_of_year
:= NULL;
WHEN 'month' THEN
                NEW.day_of_week := NULL;
                NEW.month_of_year
:= NULL;
WHEN 'year' THEN
                NEW.day_of_week := NULL;
                NEW.season_start
:= NULL;
                NEW.season_end
:= NULL;
ELSE
                RAISE EXCEPTION 'Invalid interval_unit: %', NEW.interval_unit;
END
CASE;
ELSE
        NEW.interval_value := NULL;
        NEW.interval_unit
:= NULL;
        NEW.day_of_week
:= NULL;
        NEW.date_of_month
:= NULL;
        NEW.month_of_year
:= NULL;
        NEW.season_start
:= NULL;
        NEW.season_end
:= NULL;
        NEW.skip_missed_due_dates
= false;
END IF;

RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER clean_task_trigger
    BEFORE INSERT
        OR
UPDATE ON tasks FOR EACH ROW
    EXECUTE FUNCTION clean_task_data ();

-- -----------------------------------------------------------------------------------------
-- RAISE AN EXCEPTION IF USER ALREADY HAS A PENDING INVITATION TO A COLLECTION
-- -----------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION prevent_duplicate_pending () RETURNS TRIGGER AS $$
BEGIN
    IF
EXISTS (
        SELECT 1
        FROM collection_users
        WHERE collection_id = NEW.collection_id
          AND user_id = NEW.user_id
          AND status IS NULL
          AND (OLD.id IS NULL OR id != OLD.id) -- Exclude the current row for updates
    ) THEN
        RAISE EXCEPTION 'A pending invitation already exists for this user in the collection.';
END IF;
RETURN NEW;
END;
$$
LANGUAGE plpgsql;

-- Create trigger to enforce constraints before insert
CREATE TRIGGER prevent_duplicate_pending_trigger
    BEFORE INSERT
        OR
UPDATE OF status
ON collection_users FOR EACH ROW WHEN (NEW.status IS NULL)
    EXECUTE FUNCTION prevent_duplicate_pending ();

-- -----------------------------------------------------------------------------------------
-- RAISE AN EXCEPTION IF USER ALREADY HAS AN ACCEPTED INVITATION TO A COLLECTION
-- -----------------------------------------------------------------------------------------
CREATE
OR REPLACE FUNCTION prevent_duplicate_accepted () RETURNS TRIGGER AS $$
BEGIN
    IF
EXISTS (
        SELECT 1
        FROM collection_users
        WHERE collection_id = NEW.collection_id
          AND user_id = NEW.user_id
          AND status = 'ACCEPTED'
          AND (OLD.id IS NULL OR id != OLD.id) -- Exclude the current row for updates
    ) THEN
        RAISE EXCEPTION 'An accepted invitation already exists for this user in the collection.';
END IF;
RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER prevent_duplicate_accepted_trigger
    BEFORE INSERT
        OR
UPDATE OF status
ON collection_users FOR EACH ROW WHEN (NEW.status = 'ACCEPTED')
    EXECUTE FUNCTION prevent_duplicate_accepted ();

-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------ POLICIES --------------------------------------------------------
-- ------------------------------------------------------------------------------------------------
-- ------------------------------------------------------------------------------------------------

SELECT pol.policyname AS policy_name,
       pol.tablename  AS table_name
FROM pg_policies pol
ORDER BY table_name, policy_name;

-- ------------------------------------------------------------------------------------------------
-- DROP POLICIES AND DISABLE RLS
-- ------------------------------------------------------------------------------------------------
-- DROP POLICY IF EXISTS to_do_task_policy ON to_do_tasks;
-- DROP POLICY IF EXISTS tags_policy ON tags;
-- DROP POLICY IF EXISTS collection_insert_policy ON collections;
-- DROP POLICY IF EXISTS collection_select_policy ON collections;
-- DROP POLICY IF EXISTS collection_edit_policy ON collections;
-- DROP POLICY IF EXISTS collection_delete_policy ON collections;
-- DROP POLICY IF EXISTS collection_user_select_policy ON collection_users;
-- DROP POLICY IF EXISTS collection_user_update_policy ON collection_users;
-- DROP POLICY IF EXISTS collection_user_inviter_insert_policy ON collection_users;
-- DROP POLICY IF EXISTS task_log_select_policy ON task_logs;
-- DROP POLICY IF EXISTS task_log_insert_policy ON task_logs;
-- DROP POLICY IF EXISTS task_log_update_policy ON task_logs;
-- DROP POLICY IF EXISTS task_log_delete_policy ON task_logs;
-- DROP POLICY IF EXISTS task_all_policy ON tasks;
-- DROP POLICY IF EXISTS notification_insert_policy ON notifications;
-- DROP POLICY IF EXISTS notification_select_policy ON notifications;
-- DROP POLICY IF EXISTS notification_update_policy ON notifications;
-- DROP POLICY IF EXISTS authenticated_users_view_user_data ON users;
-- DROP POLICY IF EXISTS authenticated_users_update_own_data ON users;

-- ALTER TABLE IF EXISTS users DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS to_do_tasks DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS tags DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS collections DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS collection_users DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS task_logs DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS tasks DISABLE ROW LEVEL SECURITY;
-- ALTER TABLE IF EXISTS notifications DISABLE ROW LEVEL SECURITY;

-- ------------------------------------------------------------------------------------------------
-- ENABLE RLS
-- ------------------------------------------------------------------------------------------------
ALTER TABLE IF EXISTS users ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS to_do_tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS collections ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS collection_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS task_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS notifications ENABLE ROW LEVEL SECURITY;

-- -----------------------------------------------------------------------------------------
-- ONLY THE USER THEMSELVES CAN SELECT, INSERT, UPDATE, DELETE THEIR OWN TO DO TASKS AND TAGS
-- -----------------------------------------------------------------------------------------
CREATE
POLICY to_do_task_policy
  ON to_do_tasks
  FOR ALL
    TO authenticated
  USING (user_id = requesting_user_id())
  WITH
    CHECK (user_id = requesting_user_id());

CREATE
POLICY tags_policy
  ON tags
  FOR ALL
    TO authenticated
  USING (user_id = requesting_user_id())
  WITH
    CHECK (user_id = requesting_user_id());

-- -----------------------------------------------------------------------------------------
-- COLLECTION MEMBERS CAN ACCESS DATA AND EDIT IT BUT ONLY THE OWNER CAN DELETE IT
-- -----------------------------------------------------------------------------------------
CREATE
POLICY collection_insert_policy
  ON collections
  FOR INSERT
    TO authenticated
  WITH CHECK (true);

CREATE
POLICY collection_select_policy
  ON collections
  FOR
SELECT
    TO authenticated
    USING (
    EXISTS (
    SELECT
    1
    FROM
    collection_users
    WHERE
    collection_users.collection_id = collections.id
    AND collection_users.user_id = requesting_user_id ()
    AND (collection_users.status = 'ACCEPTED' OR collection_users.status IS NULL)
    )
    OR collections.owner_id = requesting_user_id ()
    );

CREATE
POLICY collection_edit_policy
  ON collections
  FOR
UPDATE
    TO authenticated
    USING (
    EXISTS (
    SELECT
    1
    FROM
    collection_users
    WHERE
    collection_users.collection_id = collections.id
    AND collection_users.user_id = requesting_user_id ()
    AND collection_users.status = 'ACCEPTED'
    )
    );

CREATE
POLICY collection_delete_policy
  ON collections
  FOR DELETE
TO authenticated
  USING (collections.owner_id = requesting_user_id());

-- -----------------------------------------------------------------------------------------
-- ONLY USERS THEMSELVES CAN ADJUST THEIR COLLECTION MEMBERSHIP STATE (NULL -> ACCEPTED/REJECTED, ACCEPTED -> CANCELLED), exc. THE COLLECTION OWNER CAN REMOVE USERS (ACCEPTED -> REMOVED)
-- -----------------------------------------------------------------------------------------
CREATE
POLICY collection_user_select_policy
  ON collection_users
  FOR
SELECT
    TO authenticated
    USING (true);

CREATE
POLICY collection_user_inviter_insert_policy
  ON collection_users
  FOR INSERT
    TO authenticated
  WITH
    CHECK (invited_by_id = requesting_user_id ());

CREATE
POLICY collection_user_update_policy
  ON collection_users
  FOR
UPDATE
    TO authenticated
    USING (
    collection_users.user_id = requesting_user_id ()
    OR EXISTS (
    SELECT
    1
    FROM
    collections
    WHERE
    collections.id = collection_users.collection_id
    AND collections.owner_id = requesting_user_id ()
    )
    );

-- -----------------------------------------------------------------------------------------
-- USER CAN MODIFY TASK LOGS ABOUT THEMSELVES
-- -----------------------------------------------------------------------------------------
CREATE
POLICY task_log_select_policy
  ON task_logs
  FOR
SELECT
    TO authenticated
    USING (
    EXISTS (
    SELECT 1
    FROM tasks t
    JOIN collections c ON t.collection_id = c.id
    JOIN collection_users cu ON c.id = cu.collection_id
    WHERE
    task_logs.task_id = t.id
    AND cu.user_id = requesting_user_id()
    AND cu.status = 'ACCEPTED'
    )
    );

CREATE
POLICY task_log_insert_policy
  ON task_logs
  FOR INSERT
    TO authenticated
  WITH
    CHECK (user_id = requesting_user_id ());

CREATE
POLICY task_log_update_policy
  ON task_logs
  FOR
UPDATE
    TO authenticated
    USING (task_logs.user_id = requesting_user_id ());

CREATE
POLICY task_log_delete_policy
  ON task_logs
  FOR DELETE
TO authenticated
  USING (task_logs.user_id = requesting_user_id ());

-- -----------------------------------------------------------------------------------------
-- ONLY THE ACCEPTED COLLECTION MEMBERS CAN SELECT, INSERT, UPDATE, DELETE TASKS TO A COLLECTION
-- -----------------------------------------------------------------------------------------
CREATE
POLICY task_all_policy
  ON tasks
  FOR ALL
    TO authenticated
  USING (
    EXISTS (
      SELECT
        1
      FROM
        collection_users
      WHERE
        collection_users.collection_id = tasks.collection_id
        AND collection_users.user_id = requesting_user_id ()
        AND collection_users.status = 'ACCEPTED'
    )
  );

-- -----------------------------------------------------------------------------------------
-- USERS CAN SEE AND MODIFY (READ) THEIR OWN NOTIFICATIONS
-- -----------------------------------------------------------------------------------------
CREATE
POLICY notification_insert_policy
  ON notifications
  FOR INSERT
    TO authenticated
  WITH CHECK (true);

CREATE
POLICY notification_select_policy
  ON notifications
  FOR
SELECT
    TO authenticated
    USING (notifications.user_id = requesting_user_id());

CREATE
POLICY notification_update_policy
  ON notifications
  FOR
UPDATE
    TO authenticated
    USING (notifications.user_id = requesting_user_id());

-- -----------------------------------------------------------------------------------------
-- USERS CAN SEE OTHER USERS' DATA BUT ONLY MODIFY THEIR OWN
-- -----------------------------------------------------------------------------------------
CREATE
POLICY authenticated_users_view_user_data
  ON users
  FOR
SELECT
    TO authenticated
    USING (true);

CREATE
POLICY authenticated_users_update_own_data
  ON users
  FOR
UPDATE
    TO authenticated
    USING (users.id = requesting_user_id())
WITH
    CHECK (users.id = requesting_user_id());

-- -----------------------------------------------------------------------------------------
-- ALLOW AUTHENTICATED USERS TO UPLOAD/DOWNLOAD PHOTOS IN THE "FILES" BUCKET
-- -----------------------------------------------------------------------------------------

-- Use Postgres to create a bucket.
insert into storage.buckets (id, name)
values ('files', 'files');

CREATE
POLICY authenticated_users_upload_download_photos
  ON storage.objects
FOR ALL
  TO authenticated
USING (bucket_id = 'files');

-- -----------------------------------------------------------------------------------------
-- ENABLING REAL-TIME UPDATES FOR RELEVANT TABLES
-- -----------------------------------------------------------------------------------------

alter table notifications replica identity full;
alter table activities replica identity full;
-- alter table task_logs replica identity full;
-- alter table tasks replica identity full;
-- alter table collection_users replica identity full;
-- alter table to_do_tasks replica identity full;
-- alter table tags replica identity full;
-- alter table task_photos replica identity full;
-- Add tables to the real-time publication

alter
publication supabase_realtime add table notifications;
alter
publication supabase_realtime add table activities;
-- alter publication supabase_realtime add table task_logs;
-- alter publication supabase_realtime add table tasks;
-- alter publication supabase_realtime add table collection_users;
-- alter publication supabase_realtime add table to_do_tasks;
-- alter publication supabase_realtime add table tags;
-- alter publication supabase_realtime add table task_photos;
